#!/usr/bin/env python3
import glob, os

def is_double(number):
    is_number = True
    try:
        num = float(number)
        # check for "nan" floats
        is_number = num == num   # or use `math.isnan(num)`
    except ValueError:
        is_number = False
    return is_number

def write(content):
    f.write(content)
def writeln(content):
    write(content)
    write("\n")
    
precision = 20

def isRepresentableAsDouble(string):
    test = string
    if "." in string:
        while test[-1] == "0":
            test.removeLast()
        
    
    if len(test) > 16:
        return False
    
    if "." in string:
        if (test == "3"):
            test = test[:-1]
            test = test + "9"
        elif (test[-1] == "."):
            test = test + "3"
        else:
            test = test[:-1]
            test = test + "3"
    else:
        if (test[-1] == "3"):
            test = test[:-1]
            test = test + "9"
        else:
            test = test[:-1]
            test = test + "3"

    selfDouble = float(string)
    testDouble = float(test)
    return testDouble != selfDouble


def assertEqual(components):
    if len(components) < 3:
        print("less than 3 components in:")
        print(components)
        return
    if components[-2] != "=":
        print("second last not \"=\"")
        print(components)
        return

    write("    leftNumber = ")
    for component in components[:-2]:
        if is_double(component):
            if len(component) <= 16:
                write("Number(" + component + ", precision: "+str(precision)+")")
            else:
                write("Number(\"" + component + "\", precision: "+str(precision)+")")
        else:
            write(" "+component+" ")
    writeln("")
    if (isRepresentableAsDouble(components[-1])):
        writeln("    #expect(leftNumber.toDouble().similarTo(" + str(components[-1]) + "))")
    else:
        solution = "Number(\"" + components[-1] + "\", precision: "+str(precision)+")"
        writeln("    #expect(leftNumber.similarTo(" + solution + "))")

# Get full file name with directores using for loop
for file in glob.glob("*.txt"):
    basename = os.path.basename(file).replace(".txt", "")

    f = open(basename+"Test.swift", 'w')
    writeln("// Note: This file is automatically generated.")
    writeln("//       It will be overwritten sooner or later.")
    writeln("")
    writeln("import Testing")
    writeln("import SwiftGmp")
    writeln("")
    writeln("@Test func "+basename+"Test() {")
    writeln("    var leftNumber: Number")
    writeln("")
    print(basename+"Test.swift")
    with open(file) as file:
        for line in file:
            line = line.strip()
            if len(line) > 0:
                contentAndComment = line.split("//")
                content = contentAndComment[0].strip()
                comment = " ".join(contentAndComment[1:]).strip()

                if len(content) == 0:
                    if len(comment) > 0:
                        writeln("// "+comment)
                else:
                    components = content.strip().split(" ")
                    if len(components) < 2:
                        write_("// "+components[0]+"\n")
                    else:
                        if components[0] == "PRECISION":
                            writeln("")
                            write_("PRECISION.")
                            write(components[1])
                            write(" = ")
                            write(components[2])
                            if len(comment) > 0:
                                write(" // "+comment)
                        else:
                            assertEqual(components)
                            if len(comment) > 0:
                                write(" // "+comment)
                        writeln("")
    writeln("}")
    f.close()
